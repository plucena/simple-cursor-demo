"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _JsonRpcSigner_instances, _JsonRpcSigner_buildInputText, _JsonRpcSigner_buildStringInputText;
Object.defineProperty(exports, "__esModule", { value: true });
exports.JsonRpcSigner = void 0;
const coti_sdk_typescript_1 = require("@coti-io/coti-sdk-typescript");
const ethers_1 = require("ethers");
const types_1 = require("../types");
const constants_1 = require("../utils/constants");
const utils_1 = require("../utils");
const EIGHT_BYTES = 8;
class JsonRpcSigner extends ethers_1.JsonRpcSigner {
    constructor(provider, address, userOnboardInfo) {
        super(provider, address);
        _JsonRpcSigner_instances.add(this);
        this._autoOnboard = true;
        this._userOnboardInfo = userOnboardInfo;
    }
    getAutoOnboard() {
        return this._autoOnboard;
    }
    getUserOnboardInfo() {
        return this._userOnboardInfo;
    }
    setUserOnboardInfo(onboardInfo) {
        if (onboardInfo) {
            this._userOnboardInfo = {
                ...this._userOnboardInfo,
                ...onboardInfo,
            };
        }
    }
    setAesKey(key) {
        if (this._userOnboardInfo) {
            this._userOnboardInfo.aesKey = key;
        }
        else
            this._userOnboardInfo = { aesKey: key };
    }
    setOnboardTxHash(hash) {
        if (this._userOnboardInfo) {
            this._userOnboardInfo.txHash = hash;
        }
        else
            this._userOnboardInfo = { txHash: hash };
    }
    setRsaKeyPair(rsa) {
        if (this._userOnboardInfo) {
            this._userOnboardInfo.rsaKey = rsa;
        }
        else
            this._userOnboardInfo = { rsaKey: rsa };
    }
    enableAutoOnboard() {
        this._autoOnboard = true;
    }
    disableAutoOnboard() {
        this._autoOnboard = false;
    }
    clearUserOnboardInfo() {
        this._userOnboardInfo = undefined;
    }
    async encryptValue(plaintextValue, contractAddress, functionSelector) {
        if (this._userOnboardInfo?.aesKey === null || this._userOnboardInfo?.aesKey === undefined) {
            if (this._autoOnboard) {
                console.warn("user AES key is not defined and need to onboard or recovered.");
                await this.generateOrRecoverAes();
                if (!this._userOnboardInfo || this._userOnboardInfo.aesKey === undefined || this._userOnboardInfo.aesKey === null) {
                    throw new Error("user AES key is not defined and cannot be onboarded or recovered.");
                }
            }
            else
                throw new Error("user AES key is not defined and auto onboard is off .");
        }
        const value = typeof plaintextValue === 'number' ? BigInt(plaintextValue) : plaintextValue;
        let result;
        if (typeof value === 'bigint') {
            result = await __classPrivateFieldGet(this, _JsonRpcSigner_instances, "m", _JsonRpcSigner_buildInputText).call(this, value, this._userOnboardInfo.aesKey, contractAddress, functionSelector);
        }
        else if (typeof value === 'string') {
            result = await __classPrivateFieldGet(this, _JsonRpcSigner_instances, "m", _JsonRpcSigner_buildStringInputText).call(this, value, this._userOnboardInfo.aesKey, contractAddress, functionSelector);
        }
        else {
            throw new Error("Unknown type");
        }
        return result;
    }
    async decryptValue(ciphertext) {
        if (this._userOnboardInfo?.aesKey === null || this._userOnboardInfo?.aesKey === undefined) {
            if (this._autoOnboard) {
                console.warn("user AES key is not defined and need to onboard or recovered.");
                await this.generateOrRecoverAes();
                if (!this._userOnboardInfo || this._userOnboardInfo.aesKey === undefined || this._userOnboardInfo.aesKey === null) {
                    throw new Error("user AES key is not defined and cannot be onboarded or recovered.");
                }
            }
            else
                throw new Error("user AES key is not defined and auto onboard is off .");
        }
        if (typeof ciphertext === 'bigint') {
            return (0, coti_sdk_typescript_1.decryptUint)(ciphertext, this._userOnboardInfo.aesKey);
        }
        return (0, coti_sdk_typescript_1.decryptString)(ciphertext, this._userOnboardInfo.aesKey);
    }
    async generateOrRecoverAes(onboardContractAddress = constants_1.ONBOARD_CONTRACT_ADDRESS) {
        if (this._userOnboardInfo?.aesKey)
            return;
        else if (this._userOnboardInfo && this._userOnboardInfo.rsaKey && this._userOnboardInfo.txHash)
            this.setAesKey(await (0, utils_1.recoverAesFromTx)(this._userOnboardInfo.txHash, this._userOnboardInfo.rsaKey, onboardContractAddress, this.provider));
        else {
            const accountBalance = await (0, utils_1.getAccountBalance)(this.address, this.provider || (0, utils_1.getDefaultProvider)(types_1.CotiNetwork.Testnet));
            if (accountBalance > BigInt(0))
                this.setUserOnboardInfo(await (0, utils_1.onboard)(onboardContractAddress, this));
            else
                throw new Error("Account balance is 0 so user cannot be onboarded.");
        }
    }
}
exports.JsonRpcSigner = JsonRpcSigner;
_JsonRpcSigner_instances = new WeakSet(), _JsonRpcSigner_buildInputText = async function _JsonRpcSigner_buildInputText(plaintext, userKey, contractAddress, functionSelector) {
    if (plaintext >= BigInt(2) ** BigInt(64)) {
        throw new RangeError("Plaintext size must be 64 bits or smaller.");
    }
    // Convert the plaintext to bytes
    const plaintextBytes = (0, coti_sdk_typescript_1.encodeUint)(plaintext);
    // Convert user key to bytes
    const keyBytes = (0, coti_sdk_typescript_1.encodeKey)(userKey);
    // Encrypt the plaintext using AES key
    const { ciphertext, r } = (0, coti_sdk_typescript_1.encrypt)(keyBytes, plaintextBytes);
    const ct = new Uint8Array([...ciphertext, ...r]);
    // Convert the ciphertext to BigInt
    const ctInt = (0, coti_sdk_typescript_1.decodeUint)(ct);
    let signature;
    const message = (0, ethers_1.solidityPacked)(["address", "address", "bytes4", "uint256"], [this.address, contractAddress, functionSelector, ctInt]);
    const messageBytes = new Uint8Array((message.length - 2) / 2);
    for (let i = 0; i < message.length - 2; i += 2) {
        const byte = parseInt(message.substring(i + 2, i + 4), 16);
        messageBytes[i / 2] = byte;
    }
    signature = await this.signMessage(messageBytes);
    return {
        ciphertext: ctInt,
        signature
    };
}, _JsonRpcSigner_buildStringInputText = async function _JsonRpcSigner_buildStringInputText(plaintext, userKey, contractAddress, functionSelector) {
    let encoder = new TextEncoder();
    // Encode the plaintext string into bytes (UTF-8 encoded)        
    let encodedStr = encoder.encode(plaintext);
    const inputText = {
        ciphertext: { value: new Array() },
        signature: new Array()
    };
    // Process the encoded string in chunks of 8 bytes
    // We use 8 bytes since we will use ctUint64 to store
    // each chunk of 8 characters
    for (let startIdx = 0; startIdx < encodedStr.length; startIdx += EIGHT_BYTES) {
        const endIdx = Math.min(startIdx + EIGHT_BYTES, encodedStr.length);
        const byteArr = new Uint8Array([...encodedStr.slice(startIdx, endIdx), ...new Uint8Array(EIGHT_BYTES - (endIdx - startIdx))]); // pad the end of the string with zeros if needed
        const it = await __classPrivateFieldGet(this, _JsonRpcSigner_instances, "m", _JsonRpcSigner_buildInputText).call(this, (0, coti_sdk_typescript_1.decodeUint)(byteArr), // convert the 8-byte hex string into a number
        userKey, contractAddress, functionSelector);
        inputText.ciphertext.value.push(it.ciphertext);
        inputText.signature.push(it.signature);
    }
    return inputText;
};
