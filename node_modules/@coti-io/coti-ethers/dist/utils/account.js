"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.printAccountDetails = printAccountDetails;
exports.getAccountBalance = getAccountBalance;
exports.validateAddress = validateAddress;
exports.getNonce = getNonce;
exports.addressValid = addressValid;
exports.getNativeBalance = getNativeBalance;
exports.getEoa = getEoa;
exports.transferNative = transferNative;
const ethers_1 = require("ethers");
const network_1 = require("./network");
const transaction_1 = require("./transaction");
async function printAccountDetails(provider, address) {
    if (!(await (0, network_1.isProviderConnected)(provider) && addressValid(address))) {
        throw Error("provider not connected or address is not valid address");
    }
    console.log("account address:", address);
    const balanceInWei = await getAccountBalance(address, provider);
    console.log("account balance: ", balanceInWei, 'wei (', (0, ethers_1.formatEther)(balanceInWei.toString()), 'ether)');
    console.log("account nonce: ", await getNonce(provider, address));
}
async function getAccountBalance(address, provider) {
    if (!(await (0, network_1.isProviderConnected)(provider) && addressValid(address))) {
        throw Error("provider not connected or address is not valid address");
    }
    return provider.getBalance(address);
}
function validateAddress(address) {
    return { 'valid': (0, ethers_1.isAddress)(address), 'safe': (0, ethers_1.getAddress)(address) };
}
async function getNonce(provider, address) {
    if (!(await (0, network_1.isProviderConnected)(provider) && addressValid(address))) {
        throw Error("provider not connected or address is not valid address");
    }
    return await provider.getTransactionCount(address);
}
function addressValid(address) {
    return validateAddress(address).valid;
}
async function getNativeBalance(provider, address) {
    if (!(await (0, network_1.isProviderConnected)(provider) && addressValid(address))) {
        throw Error("provider not connected or address is not valid address");
    }
    return (0, ethers_1.formatEther)(await getAccountBalance(address, provider));
}
async function getEoa(accountPrivateKey) {
    const wallet = new ethers_1.Wallet(accountPrivateKey);
    if (!addressValid(wallet.address))
        throw new Error("Address generated from pk is not valid");
    return wallet.address;
}
async function transferNative(provider, wallet, recipientAddress, amountToTransferInWei, nativeGasUnit) {
    const feeData = await provider.getFeeData();
    const gasPrice = feeData.gasPrice;
    const tx = {
        to: recipientAddress,
        from: wallet.address,
        value: amountToTransferInWei.toString(),
        nonce: await wallet.getNonce(),
        gasLimit: nativeGasUnit,
        gasPrice: gasPrice
    };
    try {
        await (0, transaction_1.validateGasEstimation)(provider, tx);
        const transaction = await wallet.sendTransaction(tx);
        await transaction.wait();
        console.log('Transaction successful with hash:', transaction.hash);
        return transaction;
    }
    catch (error) {
        console.error('Transaction failed:', error);
    }
}
