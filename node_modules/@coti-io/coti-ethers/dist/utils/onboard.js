"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAccountOnboardContract = getAccountOnboardContract;
exports.onboard = onboard;
exports.recoverAesFromTx = recoverAesFromTx;
const ethers_1 = require("ethers");
const network_1 = require("./network");
const coti_sdk_typescript_1 = require("@coti-io/coti-sdk-typescript");
const types_1 = require("../types");
const constants_1 = require("./constants");
const Wallet_1 = require("../wallet/Wallet");
function getAccountOnboardContract(contractAddress, runner) {
    return new ethers_1.Contract(contractAddress, JSON.stringify(constants_1.ONBOARD_CONTRACT_ABI), runner);
}
async function onboard(defaultOnboardContractAddress, signer) {
    try {
        const accountOnboardContract = getAccountOnboardContract(defaultOnboardContractAddress, signer);
        const { publicKey, privateKey } = (0, coti_sdk_typescript_1.generateRSAKeyPair)();
        let signedEK;
        if (signer instanceof Wallet_1.Wallet) {
            signedEK = (0, coti_sdk_typescript_1.sign)((0, ethers_1.keccak256)(publicKey), signer.privateKey);
        }
        else {
            signedEK = await signer.signMessage(publicKey);
        }
        const receipt = await (await accountOnboardContract.onboardAccount(publicKey, signedEK, { gasLimit: 12000000 })).wait();
        if (!receipt || !receipt.logs || !receipt.logs[0]) {
            throw new Error("failed to onboard account");
        }
        const decodedLog = accountOnboardContract.interface.parseLog(receipt.logs[0]);
        if (!decodedLog) {
            throw new Error("failed to onboard account");
        }
        const userKey1 = decodedLog.args.userKey1.substring(2);
        const userKey2 = decodedLog.args.userKey2.substring(2);
        return {
            aesKey: (0, coti_sdk_typescript_1.recoverUserKey)(privateKey, userKey1, userKey2),
            rsaKey: { publicKey: publicKey, privateKey: privateKey },
            txHash: receipt.hash
        };
    }
    catch (e) {
        console.error("unable to onboard user.");
        throw Error(`unable to onboard user.`);
    }
}
async function recoverAesFromTx(txHash, rsaKey, defaultOnboardContractAddress, provider) {
    try {
        const receipt = provider
            ? await provider.getTransactionReceipt(txHash)
            : await (0, network_1.getDefaultProvider)(types_1.CotiNetwork.Testnet).getTransactionReceipt(txHash);
        if (!receipt || !receipt.logs || !receipt.logs[0]) {
            console.error("failed to get onboard tx info");
            throw new Error("failed to get onboard tx info");
        }
        const accountOnboardContract = getAccountOnboardContract(defaultOnboardContractAddress);
        const decodedLog = accountOnboardContract.interface.parseLog(receipt.logs[0]);
        const encryptedKey = decodedLog.args.userKey;
        return (0, coti_sdk_typescript_1.decryptRSA)(rsaKey.privateKey, encryptedKey.substring(2));
    }
    catch (e) {
        console.error("failed to get onboard tx info");
        throw Error(`unable to recover aes key from transaction.`);
    }
}
